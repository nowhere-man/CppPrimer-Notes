[TOC]
# 初始化  

C++支持两种初始化形式：**直接初始化**和**拷贝初始化**。直接初始化将初始化式放在圆括号中，而拷贝初始化使用等号(＝)。
```cpp
class Foo {
public:
    Foo() { cout << "Foo()" << endl; }
    Foo(int f) { cout << "Foo(int f)" << endl; }
    Foo(const Foo&) { cout << "Foo(const Foo&)" << endl; }
};

```
## 直接初始化

+ 将变量放在圆括号中。
+ 编译器根据传入的参数选择**最匹配的构造函数**来进行初始化。
+ 直接初始化可能调用拷贝构造函数。
```cpp
// 调用Foo(int f) 
Foo f1(10);
// 调用Foo(const Foo&)
// 直接初始化，但是调用拷贝构造函数。
Foo f2(f1);
```
## 拷贝初始化  
+ 使用等号初始化一个变量。 
+ 拷贝初始化先调用对应的构造函数创建临时对象，再调用拷贝构造函数将临时对象拷贝给要创建的对象。
+ 为提高效率，允许编译器跳过创建创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化。
+ [如果编译器优化掉创建临时对现象这一步，还有两种情况下直接初始化和拷贝初始化不等价。](https://sqrt-1.me/?p=241)
```cpp
// 调用Foo(const Foo&)
// 相当于Foo f3(f2)
Foo f3 = f2;
// 只调用Foo(int),编译器优化了拷贝赋值。
Foo f4 = Foo(4);
// 第一步：隐式类型转换：10 -> Foo(10)
// 第一步：只调用Foo(int),编译器优化了拷贝赋值。
Foo f5 = 10;
```
## 列表初始化
+ 对于内置类型使用列表初始化的时候，当初始值存在丢失信息的风险，编译器会报错。
```cpp
#include <iostream>

int main()
{
    //列表初始化,值为3
    int f(3);
    int f {3};
    int f = {3};
    int f(3.14);
    //编译出错
    int g {3.14};
    int g  = {3.14};
}
```

## 不给定初始值时的初始化

###  值初始化
+ 使用了初始化器(圆括号或花括号)，但却没有提供初始值。
+ 初始值是确定的。
+ **局部静态变量**即使没有使用初始化器，也执行值初始化。
###  默认初始化
+ 定义变量时没有指定初值。
+ 初始值可能是未定义的。
+ 默认初始化变量的值与**变量的类型**及**变量定义的位置**有关系：
    - 对于基本类型，如果定义在语句块外（即｛｝外），则变量被默认初始化为0；如果定义在语句块内，变量将拥有未定义的值。
    - 对于类类型，不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发错误。
+ 特别的，采用动态分配内存的方式（使用new关键字）创建的变量，不加括号时是默认初始化，加了括号为值初始化。

```cpp
#include <iostream>

// 默认初始化，值为0
int a;
// 默认初始化，调用Foo()
int f1;

int main()
{
    // 默认初始化，值未定义
    int b;
    // 默认初始化，调用Foo()
    int f2;
    
    // 值初始化，值为0
    static int c;
    // 值初始化，值为0
    int e = int();
    // 值初始化，数组后3个元素值为0
    int d[5] = {1, 2};
    
    // 默认初始化，值未定义
    int *p1 = new int;
    // 值初始化，值为0
    int *p2 = new int();

    //列表初始化
    int f {3};
    int f {3.14};
}
```