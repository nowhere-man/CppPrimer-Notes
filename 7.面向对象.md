[TOC]
# 拷贝控制
+ 拷贝构造函数
+ 拷贝赋值运算符
+ 移动构造函数
+ 移动赋值运算符
+ 析构函数

## 拷贝构造函数
+ 构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值。

### 直接初始化和拷贝初始化的差异
+ 直接初始化使用`普通的函数匹配`来选择与我们提供的`参数最匹配的构造函数`。
+ 拷贝初始化将`右侧运算对象`拷贝到正在创建的对象中，如果需要的话还要进行类型转换。（拷贝构造函数通常不应该是explicit的）

拷贝初始化
+ 通常使用`拷贝构造函数`完成拷贝。
+ 可能使用`移动构造函数`完成拷贝。

### 拷贝初始化场景
用一个已有的对象来初始化一个新的对象时：调用拷贝构造函数。
+ 使用`=`定义变量。
+ 将一个`对象`作为`实参`传递给一个`非引用类型`的形参。
+ 从一个`返回类型为非引用类型的函数`返回一个`对象`。
+ 列表初始化数组或容器：`Foo f[4] = {f1, f2, f3, f4};`
+ 对于容器，`insert/push`会进行拷贝初始化，`emplace`会进行直接初始化。、

默认情况下编译器会优化掉对拷贝构造函数的调用，避免不必要的调用；即使没有调用拷贝构造函数，但是要求拷贝构造函数必须是可访问的。可以使用`-fno-elide-constructors`编译参数关闭编译器优化。
```cpp
class Foo {
public:
    Foo() { cout << "Foo() called" << endl;}
    Foo(int i) { cout << "Foo(int i) called" << endl;}
    Foo(const Foo&) { cout << "Foo(const Foo&) called" << endl;}
};

// Foo() called
Foo f1;

// Foo(int i) called
Foo f2(0);

// Foo(const Foo&) called
Foo f3(f2);
// Foo(const Foo&) called
Foo f4 = f3;

/*************************默认情况下***********************/
// Foo(int i) called
Foo f5 = 0;
// Foo(int i) called
Foo f6(Foo(0));
// Foo(int i) called
Foo f7 = Foo(0);

/*************************关闭编译器优化后***********************/
// Foo(int i) called; Foo(const Foo&) called
Foo f5 = 0;
// Foo(int i) called; Foo(const Foo&) called
Foo f6(Foo(0));
// Foo(int i) called; Foo(const Foo&) called
Foo f7 = Foo(0);

```

## 拷贝赋值运算符

+ 赋值运算符是一个名为`operator=`的函数，返回值为左侧运算对象的引用。
    ```cpp
    Foo& operator=(const Foo&)
    ```
+ 赋值运算符必须定义为成员函数。左侧运算对象`绑定到this的引用`。
+ 拷贝赋值运算符会将右侧运算对象的每个`非static成员`赋给左侧运算对象的对应成员。


### 拷贝赋值运算符和拷贝构造函数
+ 为一个`之前不存在的对象`使用=赋值时（也就是初始化），调用拷贝构造函数。
+ 为一个`已有的对象`使用=赋值时，调用拷贝赋值运算符。

## 析构函数
+ 构造函数初始化对象的`非static`成员，析构函数销毁对象的`非static`成员。

### 析构函数完成的工作
+ 构造函数有一个初始化部分和一个函数体，`先初始化`，再执行函数体；按在类中出现的顺序`依次`初始化。
+ 析构函数有一个函数体和一个析构部分，`先执行函数体`，再销毁对象；按初始化顺序的`逆序`销毁。

### 调用析构函数时机
+ 变量离开作用域被销毁。
+ 对象被销毁时，其成员被销毁。
+ 容器被销毁时，其元素被销毁。
+ 动态分配的对象，应用delete时被销毁。
+ 对于临时对象，当创建它的完整表达式结束时被销毁。

+ 隐式销毁一个内置指针类型的成员不会delete它所指的对象。
+ 当指向对象的`引用`或`指针`离开作用域时，`不会执行析构函数`。

## 三/五法则

+ 需要析构函数的类也需要拷贝和赋值操作。
+ 需要拷贝操作的类也需要赋值操作。
+ 需要赋值操作的类也需要拷贝操作。

### =default/=delete
+ 只能对`默认的成员函数`使用=defalut；可以对`任意函数`指定=delete；
+ =default直到编译器生成代码时才需要（类内、类外都可以指定，在类内声明时指定默认是inline的，在类外定义时指定默认不是inline的）；=delete`必须出现在函数第一次声明`的时候。

+ 析构函数不能指定为=delete。(如果指定为=delete，定义普通变量会报错；定义动态分配的变量时不会报错，但是delete时会报错)

如果一个类的数据成员不能默认构造，拷贝，赋值或销毁，则该类的`默认拷贝控制成员`就定义为删除的。  
额外的：
+ 一个成员有删除的或不可访问的析构函数，其默认构造函数和默认拷贝构造函数被定义为删除的。
+ 具有const成员或引用成员的类，其`拷贝赋值运算符`是删除的。

+ 具有引用成员或无法默认构造的const成员的类，其默认构造函数是删除的。
