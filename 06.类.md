[TOC]
# 类

> 类的基本思想是`数据抽象`和`封装`。数据抽象是一种依赖于`接口`和`实现`分离的编程技术。封装则实现了类的接口和实现的分离。

## 定义抽象数据类型

### 成员函数 
+ 定义在类内部的函数是隐式的inline函数。

### this
+ this是一个常量指针(`T* const`)。不允许改变保存在this中的指针。
+ 当我们调用一个成员函数时，用请求该函数的对象地址初始化this。
+ 任何对类成员的直接访问都被看作this的隐式引用。

### 常量成员函数（参数列表后紧跟const) 
+ 修改this指针的类型： `const T* const`。表示this是一个指向常量的常量的指针。
+ 常量成员函数只有`get`权限。
+ 常量对象，常量对象的引用或指针都`只能调用常量成员函数`。

### 编译器处理类
+ 处理成员的声明。
+ 处理成员函数体。

### 定义返回this对象的函数

```cpp
// 类的声明
class Foo
{
    int a;
    int b;
    Foo& combine(const Foo& f);
}

// 成员函数实现

// 内置的赋值运算符把它的左侧对象当作左值返回，
// 这里模仿+=运算符，返回一个引用类型。
//(调用一个返回引用的函数得到一个左值，其他返回类型得到右值)。
Foo& Foo::combine(const Foo& f)
{
    a += f.a;
    b += f.b;
    return *this;
}

// 调用
Foo f1;
Foo f2;
f1.combine(f2);
```
+ 内置的赋值运算符把它的左侧对象当作左值返回。
+ 调用一个返回引用的函数得到一个左值，其他返回类型得到右值。
+ 一个const成员函数如果以引用的形式返回*this,那么它的返回值则是常量引用。

### 拷贝、赋值和析构
+ 编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。
+ 当类需要分配类对象之外的资源时，合成的版本通常会失效。

## 访问控制与封装

### 访问控制
+ class和struct的唯一区别就是成员默认的访问权限。

### 友元
+ 允许其他类或者函数访问它的非公有成员。
+ 友元声明只能出现在类定义的内部。
+ 友元不是类成员，不受它所在区域访问控制级别的约束。
+ 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。必须在友元声明之外再专门对函数进行一次声明。(对大多编译器来说是非必须的)

```cpp
class Foo
{
// 友元函数声明
friend void friend_test(Foo& f);
private:
    int a;
};

void friend_test(Foo& f)
{
    cout << "using private member a: " << f.a << endl;
}

int main() 
{
    Foo f;
    friend_test(f);
    system("pause");
}
```

## 类的其他特性
---
### 定义一个类型成员
+ 用来定义类型的成员必须先定义后使用。
```cpp
class Foo
{
public:
    typedef std::string::size_type pos;
    using pos = std::string::size_type;
}
```
### mutable：可变数据成员
+ 一个可变数据成员永远不会是const，即使它是const成员对象的成员。即：一个const成员函数可以改变一个mutable成员的值。
```cpp
class Foo
{
public:
    void add() const
    {
        ++a;
    }
private:
    mutable int a;
}
```
### 类成员初始值
+ 类内初始值必须使用`=`或者`花括号括起来`的初始化形式。

### 类的声明
声明类而不定义使用场景十分有限：
+ 定义指向类类型的指针或引用。
+ 声明类类型作为参数或者返回类型的函数。  

类定义之后，编译器才能知道存储该数据成员需要多少空间，所以一个类的成员类型不能是该类自己。但是类允许包含指向它自身类型的引用或指针，因为一旦一个类的名字出现后，它就被认为是声明过了。

### 友元再探
友元类：
```cpp
class Foo
{
    friend class Bar;
}
```
+ 一个类指定了友元类，则友元类的成员函数可以访问此类的所有成员。
+ 友元关系不存在传递性，每个类只负责控制自己的友元。

## 类的作用域

 + 一个类就是一个作用域。
 + 一旦遇到了类名，定义的剩余部分就在类的作用域内了。所以返回类型必须指定所属类。
 + 类的定义分两部处理：
    + 编译成员的声明。
    + 直到类全部可见后才编译函数体。
 + 如果成员使用了外层作用域中的某个名字，而该名字`代表类型`，则类中不能再`重新定义`该名字。
 + 使用this->member显式指定使用成员变量。
 + 使用::var显式使用类作用域外的变量。
 + 当成员定义在类外时，在成员定义中使用的外部函数或者变量必须定义在该成员定义之前。

## 构造函数

### 基础
+ 构造函数不能被声明为const。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取到其常量属性。
+ 只有当类没有显式声明任何构造函数时，编译器才会自动生成默认构造函数。
+ `Foo() = default;` 显式要求编译器自动生成默认构造函数。
+ 如果成员是const或者引用的时候，必须将其初始化。
+ 对于`构造函数初始值列表`方式的初始化来说，成员初始化的顺序和`定义顺序`一致，而和构造参数的形参顺序无关。
+ 如果成员`定义`时有`初始值`，`只有调用默认构造函数`时这个初始值才会被赋给成员。
+ 如果构造函数的所有参数都有默认值，那么它就是默认构造函数。

### 委托构造函数
+ 先执行受委托的构造函数的函数体，再执行委托者的函数体。
```cpp
class Foo
{
public:
    Foo(int val1, int val2):i(val),j(val2) {}
    // 委托构造函数
    Foo(int val):Foo(val,val) {}
private:
    int i;
    int j;
}
```
### 使用默认构造函数
```cpp
// 正确，调用默认构造函数
Foo f;
// 错误，声明了一个函数
Foo f();
```

### 转换构造函数

+ 构造函数只接受一个实参，编译器会自动调用相应的构造函数
```cpp
class Foo
{
public:
    Foo(string s): val(s) {}
private:
    string val;
}

// 等价于Foo f("hello"), 不会调用拷贝构造函数
Foo f = string("hello");
// 错误，只会进行一次类型转化，就是变量类型到对象类型,不会把const char[]转为string
Foo f = "hello";
```
### explicit
+ 阻止构造函数进行隐式类型转换。
+ `只对有一个实参的构造函数有效`，事实上多个参数的构造函数也不能进行隐式转换。
+ 只能在`类内部`使用。
+ 只能`对构造函数使用`，在类外定义函数时不能再重复添加explict.
+ explicit构造函数只能用于`直接初始化`。
```cpp
// 正确
Foo f("1");
Foo f = Foo("1");

// 错误
Foo f = "1";
```

### 聚合类
满足以下条件：
+ 所有成员都是public。
+ 没有定义任何构造函数。
+ 没有类内初始值。
+ 没有基类。
+ 没有虚函数。

可以用`初始列表`来初始化聚合类：
+ 如果初始化列表元素个数少于类成员数量，靠后的成员会被`值初始化`。
```cpp
class Foo {
public:
    int a;
    string b;
}

//顺序必须和成员定义顺序一致。
Foo f = {0, "hello"};
```
### 字面值常量类
+ constexpr函数的`参数`和`返回值`必须是`字面值类型`。
+ 如果类中有constexpr函数，则该类必须符合constexpr函数的所有要求，这样的类是隐式const的。

constexpr函数要求：
+ 函数中只能有一个return语句(但允许包含typedefs,using,declaration,静态断言等);
+ 只能调用其它constexpr函数;
+ 只能使用全局constexpr变量;

字面值常量类要求：
+ 数据成员都是字面值类型。
+ 类中至少含有一个constexpr函数。
+ 如果有类内初始值，则初始值必须是常量表达式；如果成员是类类型，则初始值必须使用该类的constexpr构造函数。
+ 类必须使用析构函数的默认定义。

constexpr构造函数
+ 构造函数不能是const的，但可以是constexpr的,constexpr构造函数一般只进行列表初始化，函数体体一般是空的。
+ constexpr构造函数必须初始化所有数据成员。

### 类的静态成员
+ 静态成员函数不包含this指针。
+ 静态成员`函数`不能为const的，因为const是修饰this的。
+ 使用： 类名::静态成员。
+ 当在类外部定义静态成员时，不能重复static关键字。
+ 在类内只是声明静态成员，必须在类外定义静态成员。
```cpp
class Foo {
private:
    // 声明
    static int val;
    static int calc() 
    {
        return 1;
    }
}
// 定义
// 虽然calc()是private的，但是前面已经出现类名，后面就是在类的作用域内了，所以可以直接用。
int Foo::val = calc();
```
+ 不能在类内部初始化静态成员，必须在类外部初始化静态成员。
+ 可以在类内初始化static const/constexpr成员，这时候既是声明也是定义，但是要求static const成员是constexpr的，初始值必须是常量表达式，
+ 静态数据成员的类型可以是它所属类的类型，非静态只能是所属类的引用或指针。
+ 可以使用静态成员作为默认实参。
```cpp
class Foo {
public:
    Foo(int = val);
private:
    static int val;
   
}
// 定义
// 虽然calc()是private的，但是前面已经出现类名，后面就是在类的作用域内了，所以可以直接用。
int Foo::val = calc();
```
# 拷贝控制
+ 拷贝构造函数
+ 拷贝赋值运算符
+ 移动构造函数
+ 移动赋值运算符
+ 析构函数

## 拷贝构造函数
+ 构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值。

### 直接初始化和拷贝初始化的差异
+ 直接初始化要求编译器使用普通的函数匹配来选择与我们提供的`参数最匹配`的构造函数。
+ 拷贝初始化要求编译器将`右侧运算对象`拷贝到正在创建的对象中，如果需要的话还要进行类型转换。（拷贝构造函数通常不应该是explicit的）
+ 拷贝初始化
    + 通常使用`拷贝构造函数`完成拷贝。
    + 可能使用`移动构造函数`完成拷贝。
+ 拷贝初始化在下列情况下发生：
    + 使用`=`定义变量。
    + 将一个`对象`作为`实参`传递给一个`非引用类型`的形参。
    + 从一个`返回类型为非引用类型的函数`返回一个`对象`。
    + 用`花括号列表`初始化`一个数组中的元素`或`一个聚合类中的成员`。
    + 对于容器，`insert/push`会进行拷贝初始化，`emplace`会进行直接初始化。
## 拷贝赋值运算符
+ 赋值运算符是一个名为`operator=`的函数。
    ```cpp
    Foo& operator=(const Foo&)
    ```
+ 赋值运算符必须定义为成员函数。左侧运算对象绑定到this的引用。